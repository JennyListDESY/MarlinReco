%\begin{center}
%{\large \bf
%MarlinReco \\ ----- \\ 
%a Marlin based Reconstruction Package for the ILC}
%\end{center}

\title{ \huge{MarlinReco} \\ A Marlin based Reconstruction Package for the ILC }
\author{T.Kraemer et.al., DESY}

\maketitle
\tableofcontents
\newpage

\begin{abstract}
This document is meant to serve as a comprehensive manual to help 
users getting started with the Marlin based reconstruction software MarlinReco
for the international linear collider (ILC). 
After a short review of the underlying packages 
(LCIO, Gear, Marlin, MarlinReco) and a summary of required libraries,
a introduction to the features of MarlinReco is given. 
Furthermore a detailed description helps to install MarlinReco  
together with all underlying packages. It is also explained how
to invoke MarlinReco and influence its behaviour using the steering file.
Finally you learn how to write own processors so that many 
scientist from the HEP community can contribute to this Project.  
\end{abstract}

\section{Introduction}

The 1~TeV electron positron collider ILC is the next big project proposed by
the high energy physics community. The detectors for this collider will be
precision experiments with highly granular calorimetry and excellent tracking
capabilities. The detector development and optimisation heavily depend on 
sophisticated simulation and reconstruction software.
MarlinReco is a software package for the reconstruction of events using 
(simulated) raw data of an ILC detector. The different reconstruction 
algorithms i.e. 
track finding or cluster reconstruction are implemented in separate modules 
called processors. To improve the modularity, algorithms 
common to more processors are separated and implemented in a dedicated 
utility section. In the phase of the detector development as well as
during data taking the detector may change more or less. In order to adopt 
the reconstruction to the modified detector layout, the processors are 
developed to be independent of the detector geometry as fare as that is 
possible. The actual geometry of the detector is then provided to the 
processors using a geometry interface. 
This structure not only allows the interchange of different
reconstruction methods for a specific component of the detector, it also opens
the possibility to use the same reconstruction for different 
detector concepts. A high level of modularity ensures the
extendibility of the package and supports distributed development.

MarlinReco mainly depends on the analysis and reconstruction 
software framework Marlin~\cite{ref_marlin} and on the data and persistency 
model LCIO~\cite{ref_lcio,ref_lciohome}.

The Software is portable so that it can be used on a wide range of 
different UNIX systems. With some effort it also can be installed under
MS Windows XP.  

\section{Dependency on other Packages}

In order to keep the software light weight and easy to use, 
it is tried to keep the dependencies as moderate as possible.
Nevertheless some packages have to be available on your system to run  
MarlinReco.

\subsection{LCIO}

LCIO is a persistency framework and data model that has been adopted as a
standard by the international ILC community. It defines an abstract event
data model with hits, tracks, clusters etc. and a concrete file format to
store the data. The LCIO API (Application Programming Interface)
has been implemented in a way that makes the user code
independent of the concrete file format. So the file format could be exchanged
without breaking any existing user code if the need arose in the future.

While LCIO defines in principle the complete event data model for ILC studies,
often users will need to store additional data together with the event data.
This is possible with the help of an abstract interface called
{\em LCGenericObject} which holds arbitrary numbers of the simple types
{\em int, float} and {\em double}. Through this interface virtually any data
can be stored in LCIO files.

\subsection{Marlin}

Marlin ({\bf M}odular {\bf A}nalysis and {\bf R}econstruction for the
{\bf LIN}ear collider) is a simple and generic
\CPP application framework for the analysis of LCIO data that provides a
platform for the distributed development of new reconstruction
algorithms. Marlin supports the implementation of different tasks in individual
modules, where tasks can be as simple as creating and filling one
histograms or as complex as track finding and fitting
in the central tracker. As modules serve dedicated subclasses of
the class {\em Processor}.
Marlin uses LCIO also as its transient data model, i.e.
the LCIO event class serves as a container of the data that is
{\em shipped} from module to module as shown schematically in 
fig.~\ref{fig_marlin}. 

\begin{figure}[htb]
%\vspace{3mm}
\centering
\includegraphics*[width=65mm,angle=0]{marlin.eps}
\caption{
Schematic overview of the modular structure of Marlin. LCIO is used as the 
transient data model where the LCIO event serves as a
container of the data seen by the {\em Processors}.
}
\label{fig_marlin}
\end{figure}

 Marlin applications are entirely configured through XML steering files.
The XML files hold arbitrary named parameters - defined
either for a particular processor, a group of processors or globally. The
steering files also define the order in which the
processors are called as well as optionally logical conditions assigned to
some processors that are evaluated at runtime. 

Marlin is released with a number of processors implementing some core
functionality such as creating histograms,
simple fast smearing algorithms or conditions data handler.

\subsection{Gear}

One important ingredient for reconstruction software is the geometrical
description of the detector which is been used to record the events. 
Gear~\cite{ref_gear} is a geometry description toolkit for ILC reconstruction software, 
defining an abstract interface for the description of an ILC detector.
This description is different from the geometry description needed for the 
detailed simulation of the detector response, though of course related. For the
simulation one needs very detailed knowledge of the material
distribution in space whereas for the reconstruction mostly a higher
level description of the subdetector's characteristics is needed.
Depending on the particular reconstruction algorithm a hand full of
parameters might suffice to describe a full subdetector, e.g. the main
calorimeters - 
This description is certainly a lot less than what is needed for the
computation of the detailed detector response with GEANT4~\cite{ref_geant4}. 
Of course the required parameters could be defined in the Marlin steering 
file. However this procedure is error prone and tedious as the parameters 
usually have to be extracted manually 
from some other source, typically the full simulation
program that has been used. 
The aim of Gear is now to provide the interface to a 
global source of information for the reconstruction view of the
detector geometry.

A first implementation uses XML files for the definition of the
subdetector's geometry parameters in Gear. The user code however only applies 
the abstract interface and is thus independent from the XML-file
implementation.

Currently under development is an
implementation for the abstract interface to generic material
properties in space, like the material's density at a given point or
the integrated B-field along a (straight) path between two points.

The decoupling of the geometrical 
information of the detector from the reconstruction is the only way to get
algorithms being independent of a specific detector model. 

\subsection{MarlinUtil}

The MarlinUtil package is a library with commonly used classes and functions. 
All these classes and functions can be accessed from any processors in 
Marlin by simply binding in this package. The content of the library can be 
roughly divided into four sets:

\begin{enumerate}
\item Extension Classes for Tracker- and Calorimeter Hit classes. 
      They expand the functionality of the corresponding, native LCIO classes.
      Moreover there is a class for grouping track segments.
\item Cluster Shape and Helix classes. These classes provide analysis 
      functionality for clusters of calorimeter hits, such as calculating 
      centre of gravity as well as fits of cluster shapes and simple helixes.
\item CED classes. These are intrinsic classes needed for the handling of the 
      C Event Display (CED).
\item Miscellaneous classes, such as classes for printing the Monte Carlo 
      particle tree of a LCIO file to the standard output and headers with 
      math and physics constants.
\end{enumerate}

This library is under current development, so it will evolve in the future.

\subsection{AIDA}

\subsection{Other Libraries}

Marlin~\cite{ref_marlin} and some of the MarlinReco processors depend on the
``Class Library for High Energy Physics'' (CLHEP)~\cite{ref_clhep}. 
It is recommended to use the version 1.8.2. Version 2.0 and higher use a 
own CLHEP namespace. This has not jet implemented in Marlin, therefore those
CLHEP releases are not compatible to Marlin. This choice has been 
made to use the same CLHEP version for the Reconstruction and simulation 
(GEANT~4~\cite{ref_geant4}). In addition the ``GNU Scientific Library'' 
(GSL)~\cite{ref_gsl} is required. 

The TPC reconstruction algorithms are taken from former LEP experiments.  
they are coded in FORTRAN~77 and depend on the ``CERN Program Library'' 
(CERNLIB)~\cite{ref_cernlib}. 

\section{MarlinReco}

In this section an introduction to the MarlinReco software and the
visualisation of (reconstructed) events using the 
CED (C Event Display) program is given. Furthermore it is explained how to 
run a MarlinReco job to do reconstruction. The last subsection 
contains a short tutorial that shows you how to write your own Marlin 
processor. 

\subsection{Reconstruction Algorithms}

The heart of the reconstruction package are the Marlin processors
which hold the different modules of algorithms to get tracks and 
clusters from the simulated data. This section is meant to give a short 
introduction to the different processors currently available. More detailed 
information, especially about the usage of the modules and their 
steering parameters can be obtained in the API documentation, which can be
build together with MarlinReco. 

\subsubsection{Digitisation}

There are digitisation algorithms available for the TPC and the 
calorimeters. 
The TPC digitisation converts a 
{\em SimTrackerHit} to a {\em TrackerHit} by smearing in $r-\phi$ and $z$ 
direction.

The calorimeter digitiser processor 
takes a {\em SimCalorimeterHit} and produces a {\em CalorimeterHit}. 
The simulated energy depositions in the active 
layers of the calorimeters are converted into physical energy. 
This is done by taking into account the sampling fractions of 
the electromagnetic and hadronic calorimeters (ECAL, HCAL). 

For the vertex detector and
the forward tracking system only dummy processors that do not apply any 
smearing exist.

{\bf Available processors:} 
\begin{itemize}
\item {\em FTDDigiProcessor}
\item {\em TPCDigiProcessor}
\item {\em VTXDigiProcessor}
\item {\em MokkaCaloDigi} 
\item {\em SimpleCaloDigi}
\end{itemize}

\subsubsection{TPC Tracking}

The TPC tracking produces {\em Tracks} from TPC {\em TrackerHits} using LEP 
tracking algorithms taken from the Fortran based reconstruction program 
Brahms~\cite{ref_brahms}. 
They do not contain the DELPHI ambiguity resolver yet.
Currently only the TPC pattern recognition and fitting is implemented, though 
plans to incorporate vertex hits into tracks exist.

The final track fitting is done using a Kalman filter. At present both, 
the magnetic field and the material description of the TPC is hard coded into 
the Fortran and C++ code.
This will be improved as soon as Gear~\cite{ref_gear} becomes more evolved.
% ### DAS SOLL S.Aplin nochmal nachpruefen...

{\bf Available processors:} 
\begin{itemize}
\item {\em LEPTrackingProcessor}
\end{itemize}

\subsubsection{Clustering Algorithm}

The processor performs clustering of calorimeter hits without
using information about reconstructed tracks. 
The dependence of the clustering procedure on the detector
geometry is minimised. Only the follwoing quanteties are used: 
\begin{itemize}
\item radius of the ECAL barrel 
\item n-fold symmetry of barrel (n = 8 for TESLA)
\item $\phi$ offset of the barrel stave w.r.t. the x-axis 
      (0 for TESLA detector) 
\item $\pm z$ coordinate of front face of ECAL endcaps 
\end{itemize}
These parameters are taken from the Gear~\cite{ref_gear} XML file.

{\bf Available processors:} 
\begin{itemize}
\item {\em TrackwiseClustering}
\end{itemize}

\subsubsection{Particle Flow Algorithm}

The algorithm matches {\em Clusters} to {\em Tracks}, reconstructs particles 
and performs
particle identification on the basis of the energy fraction deposited 
in the ECAL. If this fraction is greater than a predefined threshold, 
the particle is regarded to be a photon or electron depending on 
whether a track is matched to the cluster.
Likewise muons and neutral and charged hadrons are identified. 

The algorithm depends on the same geometrical quantities as the 
{\em TrackwiseClustering} processor. In addition it considers the
magnetic field.

{\bf Available processor:} 
\begin{itemize}
\item {\em Wolf}
\end{itemize}

\subsubsection{Cheaters}

Cheater processors construct tracks or clusters by combining hits, produced 
by the full detector simulation with Monte Carlo information.
These processors can be used to benchmark and test existing algorithms
or as replacement for yet to be written parts of the reconstruction.

At the moment there are two cheaters available:

{\bf Track Cheater:} \\
It constructs true tracks by comprising all the {\em TrackerHits} attributable
to the same (Monte Carlo) particle. If a track has more than a given number of
hits and if the particle producing it carries at least a certain 
energy it is considered. The Monte Carlo information 
(momentum and vertex) is used to define the track parameters
$d_0, z_0, \phi, \tan\lambda$ and $\omega$.
Optional a fit can be performed to the {\em TrackerHits} assigned to a track
to extract the track parameters. 

{\bf Cluster Cheater:} \\
This processor constructs true clusters, where a true cluster comprises all 
hits attributed to the same generator particle entering 
the calorimeter. Hits produced by back-scattered particles are assigned to the 
primary which initiated this back-scattered particle. 
Clusters are considered only if they have at least a predefined number of 
hits. 
To avoid collecting remote hits produced by neutrons or backscattered 
particles, a proximity criterion is introduced in terms 
of a particle-to-hit distance cut. A hit is assigned to the cluster 
produced by a neutral particle if 
the following condition is fulfilled: 
$$
D\{\textrm{hit-to-vertex}\} \cdot \alpha < \textrm{ProximityCut}
$$
$D\{$hit-to-vertex$\}$ is the distance of the hit to the point 
where the neutral particle has been produced, and $\alpha$ is the 
angle between the particle momentum vector and the vector connecting 
the particle vertex and the hit. 
For charged particles, the distance from the hit to 
the helix associated with the particle trajectory should
not exceed the proximity cut. 

{\bf Available processors:} 
\begin{itemize}
\item {\em TrackCheater}
\item {\em ClusterCheater}
\end{itemize}

\subsubsection{Event Shape Variables}

There are several processors to calculate different event shape variables:

\begin{itemize}
\item Calculation of the thrust axis and thrust value for each event using two
      different algorithms:
      The Tasso algorithm calculates only the principle thrust value and axis.
      Jetset algorithm calculates the principle thrust value and axis
      as well as the major and minor thrust value and axis.   
\item Calculation of the sphericity and aplanarity. 
\item A universal jet finder module originally developed by Satoru Yamashita for
   OPAL.
\end{itemize}

{\bf Available processor:} 
\begin{itemize}
\item {\em ThrustReconstruction}
\item {\em Sphere}
\item {\em SatoruJetFinderProcessor}
\end{itemize}

\subsection{Structure of a MarlinReco Steering File}

Building MarlinReco with the top level makefile automatically produces a
Marlin executable in the directory {\tt \$LCSoft/Marlin/bin} named 
{\tt Marlin}
({\tt \$LCSoft} is the path to the directory where MarlinReco is installed as
explained in section~\ref{sec:install}).
It includes all processors and is linked statically against all 
libraries needed (Marlin, Gear, CLHEP, GSL ...) except the shared libraries
provided by the linux system. 

A Marlin job is fully configured by its steering file. 
Therefore, it is a good starting point to understand how to configure a 
MarlinReco application. 
In principle there exist two formats of the Marlin steering file: 
ASCII and XML. The older ASCII steering files are somewhat restricted in their 
functionality and are only kept for downward compatibility. For that reason 
we recommend to use XML steering files and only discuss those. 
Every Marlin executable is
able to print a sample steering file to standard out. Type

\begin{verbatim}
$LCSoft/bin/Marlin -x > exampleSteeringFile.xml
\end{verbatim}

to get an 
\htmladdnormallink{example steering file in the XML format}{../scripts/exampleSteeringFileXML.txt}. You can inspect this files using your favourite
text editor (emacs, pico, vi ...). 

Every steering file starts with {\tt <marlin>} and ends with 
{\tt </marlin>}. (To include a comment at any point of the file use the 
{\tt <!-- ... -->} tag.) 
Inside the file is divided into three types of sections:

{\bf Execute Section:} \\
In this section the names of the processors which are to be 
executed are listed using the keyword {\tt processor}. 
The order of the processor names in the XML-file in this section controls the 
order of executing the processors. A typical {\tt execute} section 
could look like this:

\begin{verbatim}
<execute>
   <processor name="MyAIDAProcessor"/>
   <processor name="MyTestProcessor"/>
   <processor name="MyLCIOOutputProcessor"/>
</execute>
\end{verbatim}

It specifies three processors which are called in the order
(1) MyAIDAProcessor, (2) MyTestProcessor, (3) MyLCIOOutputProcessor.

{\bf Global Section:} \\
Here all the global settings are made: 
\begin{itemize}
\item Specification of the LCIO input files 
      (including paths) which contain the event data
\item The number of events which are to be processed
\item Turn on/off check routines to produce control plots etc. 
\end{itemize}
A typical {\tt global} section could look like this:

\begin{verbatim}
<global>
   <parameter name="LCIOInputFiles"> simjob.slcio </parameter>
   <parameter name="MaxRecordNumber" value="5001" />
   <parameter name="SupressCheck" value="false" />
</global>
\end{verbatim}

{\bf Processor Section:} \\
This section contains several blocks named {\tt processor}. Every block 
configures a certain processor and gives it a unique name. These 
names are used in the {\tt execute} section to call the processor. 
Here one processor can be configured more than once using different 
names as identifier. In this way a processor can be called several 
times with different parameters. This can be useful to 
optimise cuts or to use the same algorithm for different input collections. 
Steering parameters of processors can be of type {\em string},  
{\em int} or {\em float}. 
A typical {\tt processor} section can look like this:

\begin{verbatim} 
<processor name="MyClusterCheater" type="ClusterCheater">
 <!--Creates true clusters...-->
  <!--Calorimeter Collection Names-->
  <parameter name="CaloCollections" type="StringVec">ECAL HCAL  </parameter>
  <!--Magnetic Field-->
  <parameter name="MagneticField" type="float">4 </parameter>
  <!--Minimal Hits in Cluster-->
  <parameter name="MinimalHits" type="int">10 </parameter>
  <!--Hit To Cluster Proximity Cut-->
  <parameter name="ProximityCut" type="float">1200 </parameter>
  <!--SimCaloHit to CaloHit Relations Collection Name-->
  <parameter name="RelCollection" type="string">RelationCaloHit </parameter>
  <!--Trace Whole Shower Tree-->
  <parameter name="TraceWholeShower" type="int">1 </parameter>
  <!--Collection of True Clusters-->
  <parameter name="TrueClusterCollection" type="string">TrueClusters </parameter>
</processor>
\end{verbatim}

This section describes the configuration of the processor of type
{\em ClusterCheater}. It can be called in the {\tt execute} section 
using the name {\tt MyClusterCheater}:

\begin{verbatim}
<execute>
   . . .
   <processor name="MyClusterCheater"/>
   . . .
</execute>
\end{verbatim}

In the definition of a parameter not only its name and value is 
specified but also the type of the expected input(s).

\subsection{Running a MarlinReco Job}

There are several options to run the reconstruction software. One can
either use ``cheater'' processors to construct tracks and clusters or
perform realistic tracking and clustering. In the first case tracks
and clusters are considered to comprise all tracker hits or
calorimeter hits attributable to the same Monte Carlo particle. In the
latter case, realistic reconstruction is performed by using LEP
tracking code and dedicated calorimeter
clustering algorithm developed by the DESY group. Additionally, it is
possible to use a combination of ``cheater-'' and realistic tracking- or
calorimeter-clustering processors. 

At this point the information from the previous subsection should be sufficient
for you to edit the file {\tt exampleSteeringFile.xml} to get a 
\htmladdnormallink{new steering file}{../scripts/exampleJob.xml}.
This than can be used to run MarlinReco performing realistic tracking and 
clustering to produce meaningful results. 

In the {\tt global} section you have to change the name of the 
LCIO input file. For a first try you can use the file 

\begin{verbatim}
$LCSoft/packages/MarlinReco/examples/LDC/muons.slcio
\end{verbatim}

with single muon events. Place a symbolic link to this file in the 
Marlin Directory:

\begin{verbatim}
cd $LCSoft/Marlin
ln -s $LCSoft/packages/MarlinReco/examples/LDC/muons.slcio
\end{verbatim} 

Add the following 
line to the {\tt global} section to read the events from 
the file {\tt muons.slcio}:

\begin{verbatim}
<parameter name=\"LCIOInputFiles\"> muons.slcio </parameter>
\end{verbatim}

To read the whole file set {\tt MaxRecordNumber} to 0. In addition the 
reconstruction needs to know the detector geometry. 
For the ``Large Detector Concept'' this information is stored
in the file

\begin{verbatim}
$LCSoft/packages/MarlinReco/examples/LDC/gear_ldc.xml  
\end{verbatim}

Place a symbolic link to this file in the Marlin directory:

\begin{verbatim}
cd $LCSoft/Marlin
ln -s $LCSoft/packages/MarlinReco/examples/LDC/gear_ldc.xml
\end{verbatim}

The file is made available to 
MarlinReco also in the {\tt global} section by:

\begin{verbatim}
<parameter name="GearXMLFile"> ../gear/gear\_ldc.xml </parameter>
\end{verbatim}

Change the {\tt execute} section to call the appropriate processors in the
right order:

\begin{verbatim}
<execute>
   <processor name="MyTPCDigiProcessor"/>
   <processor name="MyVTXDigiProcessor"/>
   <processor name="MyFTDDigiProcessor"/>
   <processor name="MySimpleCaloDigi"/>
   <processor name="MyLEPTrackingProcessor"/>
   <processor name="MyTrackwiseClustering"/>
   <processor name="MyWolf"/>
   <processor name="MyLCIOOutputProcessor"/>
</execute>
\end{verbatim}

At this stage non of the steering parameter specific to any 
processor has to be changed. Now the Marlin executable can be invoked. 
The name of the steering file to be used is handed over as the first 
parameter:

\begin{verbatim}
cd $LCSoft/Marlin
bin/Marlin exampleJob.xml
\end{verbatim}

Be sure that you are in the right directory, otherwise the relative
paths to the LCIO file containing the events and the Gear XML file do
not work. 

After the program has finished, there is an additional file 
{\tt outputfile.slcio} in the current directory, holding the reconstructed 
events. The contents of this file can be examined using the program

\begin{verbatim}
$LCIO/bin/dumpevent file run eventt
\end{verbatim}

Here the Parameter {\tt file} is the name of the LCIO file from which the 
events are read,
{\tt run} and {\tt event} the run and event number of the event to be dumped.
The {\tt dumpevent} program prints the contents of all objects to 
the standard output device.  

To use ``cheater'' processors to construct tracks and clusters,
you have to modify the {\tt execute} section of the steering file. 
The processors {\tt MyLEPTrackingProcessor} and {\tt MyTrackwiseClustering}
are replaced by {\tt MyTrackCheater} and {\tt MyClusterCheater}:

\begin{verbatim}
<execute>
  <!--processor name="MyAIDAProcessor"/-->
  <processor name="MyVTXDigiProcessor"/>
  <processor name="MyFTDDigiProcessor"/>
  <processor name="MySimpleCaloDigi"/>
  <processor name="MyTPCDigiProcessor"/>

  <processor name="MyTrackCheater"/>
  <!--processor name="MyLEPTrackingProcessor"/-->

  <processor name="MyClusterCheater"/>
  <!--processor name="MyTrackwiseClustering"/-->

  <processor name="MyWolf"/>
  <processor name="MyLCIOOutputProcessor"/>
</execute>
\end{verbatim}

\subsection{CEDViewer to Visualise Events}

Even though the {\tt dumpevent} program from the LCIO package prints out
very detailed information about all objects of an event
this is not satisfactory. Usually a more qualitative and 
visual approach is required, especially in the early 
stages of algorithm development. Here the C Event Display (CED) can be 
employed to get a graphical view of an event. Inside a 
wire-frame sketch of the detector\footnote{
      Available models: LDC (Mokka program~\cite{ref_mokka}), 
      SiD (SLIC program~\cite{ref_slic}) and 
      GLD (Jupiter program~\cite{ref_jupiter})}, 
simulated hits ({\em SimCaloHit}, {\em SimTrackerHit}), reconstructed hits 
({\em CaloHit}, {\em TrackerHit}), Monte Carlo objects 
({\em TrueTrack}, {\em TrueCluster}) and reconstructed objects 
({\em Track}, {\em Cluster}, {\em ReconstructedParticle}) are shown. 

The CED is set up as a client server application consisting of two 
parts: 
\begin{itemize}
\item the program {\tt glced} which displays the event on the screen and 
\item the Marlin processor {\em GenericViewer}, which selects the collections 
      to be displayed.
\end{itemize}
This structure allows to run a Marlin job with event display in three
different ways: to show the events of a existing LCIO file, 
to display the events after the reconstruction or to visualise the 
different reconstruction steps done by separate processors. 

To use CED in a MarlinReco job, edit the steering file {\tt exampleJob.xml}
which you created following the instructions of the last section. 
Add the line 

\begin{verbatim}
<processor name=''MyCEDViewer''/>
\end{verbatim}

as the second last processor (before the {\tt MyLCIOOutputProcessor})
in the {\tt execute} section. In the section 
where the parameters are handed over to {\tt MyGenericViewer} 
(processor of type {\em GenericViewer}) one has to specify the 
names of the collections to display. In addition a one digit number 
{\tt 0, 1, ... 9} can be assigned to each specified collection 
in order to toggle displaying it. 

Before running MarlinReco you have to launch the {\tt glced} program:

\begin{verbatim}
cd $LCSoft/Marlin
$LCSoft/glced/glced
bin/Marlin exampleJob.xml
\end{verbatim}

Now the event is displayed after finishing the reconstruction of 
tracks, clusters and particle flow objects in the window panel activated by 
the CED program {\tt glced}.

To manipulate the event display you can either using the mouse or 
certain key commands. Controlling will work if the mouse is placed
inside the CED window. 

\begin{itemize}
\item {\em\bf Using the mouse} \\ 
      Hold a mouse button pressed while moving the mouse to 
      manipulate the display. The following functions are available: 

      \begin{center}
      \begin{tabular}{ll}
      left mouse button   & rotate \\
      middle mouse button & translate (pan)\\
      right mouse button  & zoom \\
      \end{tabular}
      \end{center}
\item {\em\bf Using keyboard commands} \\
      \begin{tabular}{ll}
      {\tt ESC} & stop and exit {\tt glced} \\
      {\tt f}   & front view. Projection of all points on the $xy$-plane.\\
      {\tt s}   & side view. Projection of all points on the $yz$-plane. \\
      {\tt c}   & centre view. A new origin for a rotation and zoom \\ 
                & is set to the current position of the mouse cursor.\\
      {\tt r}   & redisplay in some initial projection. \\
      {\tt 0, 1, ...} & toggle layers. The assignment of the layers \\
                      & is done in the steering file \\
      \end{tabular}
\end{itemize}

After an event is displayed, the system waits until the user hits a key
to continue. Please note, that since the event display is realised as a
Marlin processor, the reconstruction is also stopped as long as the computer
waits for the user entry to continue.

\subsection{Writing your own Marlin Processor}

Unless you want to add an processor to an existing package you should add a 
new package if you develop new processors to carry out reconstruction or
analysis tasks. All additional packages are expected to live in the 
{\tt \$MARLIN/packages} directory.
To decouple Marlin form the additional processors, the subdirectories holding 
these processors are linked using symbolic links to Marlin's {\tt packages} 
directory. The actual source code is placed in an individual 
subdirectory - for example {\tt MyPackage} - in {\tt \$LCSoft/packages}
and have the structure:

\begin{verbatim}
    $LCSoft/packages/MyPackage/include
                             ./src/
                             ./src/GNUmakefile
                             ./lib
\end{verbatim}

The {\tt GNUmakefile} has a target 'lib', that creates a library

\begin{verbatim}
$LCSoft/packages/MyPackage/lib/libMyPackage.a
\end{verbatim}

To set up a new package you can execute the following commands: 

\begin{verbatim}
cd $LCSoft/packages
mkdir MyPackage
cd MyPackage
mkdir include
mkdir src
mkdir lib
cd src
cp $LCSoft/Marlin/examples/mymarlin/GNUmakefile .
\end{verbatim}

Edit the {\tt GNUmakefile} to assign the name of your package 
(in this case {\tt MyPackage}) to the variable {\tt PROGNAME}.

Lets assume we want to write a processor with the name 
{\em MyProcessor}.
Each Marlin processor inherits from the class {\em Processor} and has to have
at least the following methods implemented:

\begin{itemize}
\item {\tt virtual Processor*  newProcessor()} \\
      Returns a pointer to a object of type {\em MyProcessor},
      needed for internal processor management.
\item {\tt MyProcessor()} \\
      Constructor of the class.
\item {\tt virtual void init()} \\
      Called at the begin of the job before anything is read.
      Use to initialise the processor, e.g. book histograms.
\item {\tt virtual void processRunHeader( LCRunHeader* run )} \\
      Called for every run.
\item {\tt virtual void processEvent( LCEvent * evt )} \\
      Called for every event - the working horse.
\item {\tt virtual void check( LCEvent * evt )} \\
      Called for each event after processing to produce checks or plots. 
\item {\tt virtual void end()} \\
      Called after data processing for clean up.
\end{itemize}

\begin{figure}
\begin{verbatim}
#ifndef MyProcessor_h
#define MyProcessor_h 1

#include "marlin/Processor.h"
#include "lcio.h"
#include <string>

using namespace lcio ;
using namespace marlin ;

class MyProcessor : public Processor {
  
 public:
  
  virtual Processor*  newProcessor() { return new MyProcessor ; }
  MyProcessor() ;
  virtual void init() ;
  virtual void processRunHeader( LCRunHeader* run ) ;
  virtual void processEvent( LCEvent * evt ) ; 
  virtual void check( LCEvent * evt ) ; 
  virtual void end() ;
  
 protected:

  std::string _colName ;
  int _nRun ;
  int _nEvt ;
} ;

#endif
\end{verbatim}
\caption{\label{fig:myprocessor_h}
\em Header file of defining the class {\em MyProcessor}.
}
\end{figure}

\begin{figure}
\begin{verbatim}
#include "MyProcessor.h"
#include <iostream>

#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>

using namespace lcio ;
using namespace marlin ;

MyProcessor aMyProcessor ;

MyProcessor::MyProcessor() : Processor("MyProcessor") {
  _description = "MyProcessor does whatever it does ..." ;
  registerProcessorParameter( "CollectionName" , 
                              "Name of the MCParticle collection"  ,
                              _colName ,
                              std::string("MCParticle") ) ;
}

void MyProcessor::init() { 
  printParameters() ;
  _nRun = 0 ;
  _nEvt = 0 ;
}

void MyProcessor::processRunHeader( LCRunHeader* run) { 
  _nRun++ ;
} 

void MyProcessor::processEvent( LCEvent * evt ) { 
  _nEvt ++ ;
  LCCollection* inParVec = evt->getCollection(_colname) ;
  std::cout << "Event no. " << _nEvt << " has " 
            << inParVec->getNumberOfElements() 
            << " Monte Carlo particles" << std::endl;
}

void MyProcessor::check( LCEvent * evt ) { 
  // nothing to check here - could be used to fill checkplots 
  // in reconstruction processor
}

void MyProcessor::end(){ 
   std::cout << "MyProcessor::end()  " << name() 
            << " processed " << _nEvt << " events in " << _nRun << " runs "
            << std::endl ;
}
\end{verbatim}
\caption{\label{fig:myprocessor_cc}
\em Implementation of the class {\em MyProcessor}.
}
\end{figure}

Figures~\ref{fig:myprocessor_h} and \ref{fig:myprocessor_cc}
show a very simple example for a processor which counts the number of runs and
events in a LCIO file. In addition it prints for each event the number of 
Monte Carlo particles. The collection name of the Monte Carlo particles 
can be given to the processor via a steering parameter. The default setting is
{\tt MCParticle}. The two include statements in the header file

\begin{verbatim}
#include "marlin/Processor.h"
#include "lcio.h"
\end{verbatim}

are mandatory because the class inherits from the Marlin class
{\em Processor}. Furthermore Marlin uses LCIO also as the internal data model 
and thus every processor needs to know about it. 
Besides the methods already described above, there are three variables 
declared which are used to count the number of runs and events in the
LCIO file ({\tt \_nRun}, {\tt \_nEvt}) and hold the collection name of 
Monte Carlo particles ({\tt \_colName}). 

Of course the implementation file has to include the corresponding 
header file. All additional include directives include header files
which are required by the user. The line

\begin{verbatim}
MyProcessor aMyProcessor ;
\end{verbatim}

registers the processor {\tt MyProcessor} at the Marlin framework.
In the initialisation part of the constructor of 
{\tt MyProcessor} the constructor of {\tt Processor} is called with the
name of the processor. A short description of the processor is 
stored in the string {\tt \_description}. The function call to
{\tt registerProcessorParameter()} allows to register a processor parameter
which can be set in the steering file. Together with the name of the 
processor parameter a short description, a default value and a variable
that holds the value of the parameter is specified. 

In the function {\tt init()} the processor parameters and their 
values as used in the program are printed to the standard output and 
some parameters are initialised. While 
{\tt processRunHeader()} is only used to count the number of runs,
{\tt processEvent()} is used to print the number of Monte Carlo particles for 
each event and count the number of events found in the LCIO file.
Since no checks are performed {\tt check()} is empty.
At the end of data processing {\tt end()} prints the total number of 
runs and events processed. 

% ######
\section{Installation Guide} \label{sec:install}

This section is supposed to help you to install all packages which are 
necessary to run MarlinReco. Probably some of the required software is 
already installed on your computer. The installation guide is written 
in a way that you can skip the appropriate subsections. 

\subsection{System Requirements}

LCIO, Gear, Marlin, MarlinUtil and MarlinReco have been 
developed under (SuSE) Linux and tested with gcc3.2 on Linux. 
As the ``-ansi'' switch is used during compilation
it should be fairly easy to 
port the packages to other platforms with an ANSI compliant \CPP{} compiler.
The build scripts used also require that gmake/make is installed.

In order to build LCIO you need to have a Java VM (version 1.4 or
higher) installed on your platform. This is true even if you only want
to install the \CPP{} version as the API-files are generated from an
abstract description for Java and \CPP{} using the AID~\cite{ref_aid} tool.

If histograms should be produced, the JAIDA~\cite{ref_jaida} and 
AIDA\_JNI~\cite{ref_aidajni} packages have 
to be installed on the system. 

The headerfiles are commented using the Doxygen syntax. if you wish to 
generate a browsable API documentation Doxygen 
(\htmladdnormallink{http://www.doxygen.org/}{http://www.doxygen.org/})
has to be available.

If you wish to check out the sources of Gear, Marlin, MarlinReco
and MarlinUtil directly from the CVS repositories you need
``ccvssh''
(\htmladdnormallink{http://ccvssh.sourceforge.net}{http://ccvssh.sourceforge.net}). 
The ccvssh package works as a bridge to remote CVS
pservers using SSL tunnelling.  

\subsection{Getting the Sources}

Create a directory in which you can download all sources and install 
the packages:

\begin{verbatim}
mkdir ilcsoft 
export LCSoft=$PWD/ilcsoft
cd $LCSoft
\end{verbatim}

\subsubsection*{LCIO}

If LCIO is not yet installed at your site you can get a recent copy
of the sources from the CVS repository via anonymous checkout.
Set the CVSROOT variable, e.~g. on a Linux platform running bash:

\begin{verbatim}
export CVSROOT=:pserver:anonymous@cvs.freehep.org:/cvs/lcio
\end{verbatim}

Then checkout a released version, e.~g.:

\begin{verbatim}
mkdir $LCSoft/lcio 
cd $LCSoft/lcio 
cvs co -d v01-05 -r v01-05 lcio 
\end{verbatim}

\subsubsection*{Marlin}

Also for Marlin you can get a recent copy of the sources from the CVS 
repository via anonymous checkout.
Set the {\tt CVSROOT} and {\tt CVS\_RSH} variables, e.~g. on a Linux platform 
running bash:

\begin{verbatim}
export CVS_RSH=ccvssh 
export CVSROOT=:ext:anonymous@cvssrv.ifh.de:/marlin
\end{verbatim}

Start the authentification:

\begin{verbatim}
ccvssh login
\end{verbatim}

Since ``anonymous'' does not have a password, just hit return when you are
prompted to enter your password. Then checkout the latest version:

\begin{verbatim}
cd $LCSoft
cvs co Marlin
\end{verbatim}

\subsubsection*{Gear}

You can get the recent sources from the CVS repository via anonymous checkout.
After setting the required environment variables checkout:

\begin{verbatim}
unset CVS_RSH
unset CVSROOT
export CVS_RSH=ccvssh
export CVSROOT=:ext:anonymous@cvssrv.ifh.de:/gear
ccvssh login
cd $LCSoft
cvs co gear
\end{verbatim}

\subsubsection*{MarlinUtil, MarlinReco and the CEDViewer}

The recent version of the source code of Both packages can be 
obtained from the CVS repository via anonymous checkout.
Set the environment variables and start the authentification: 

\begin{verbatim}
unset CVS_RSH
unset CVSROOT
export CVS_RSH=ccvssh 
export CVSROOT=:ext:anonymous@cvssrv.ifh.de:/marlinreco
ccvssh login
\end{verbatim}

Then checkout the latest version: 

\begin{verbatim}
mkdir $LCSoft/packages 
cd $LCSoft/packages 
cvs co MarlinReco 
cvs co MarlinUtil 
cvs co CEDViewer 
\end{verbatim}

\subsection{Building the Packages}

\subsubsection*{LCIO}

A few variables have to be set depending on your development
environment (modify as appropriate):

\begin{verbatim}
export LCIO=/lcio/v01-05 
export PATH=$LCIO/tools:$LCIO/bin:$PATH 
export JDK_HOME=/usr/lib/j2sdk
\end{verbatim}

To build the Java and \CPP{} versions you have to be in the LCIO subdirectory:

Enter the LCIO subdirectory:

\begin{verbatim}
cd $LCIO 
\end{verbatim}

Use the following command To build the Java and \CPP{} versions:

\begin{verbatim}
ant aid cpp f77 
\end{verbatim}

\subsubsection*{Gear}

Enter the Gear subdirectory:

\begin{verbatim}
cd $LCSoft/gear
\end{verbatim}

The environment variables needed for compilation and linking are in the file 
{\tt env.sh}. Open this file and adopt the line 

\begin{verbatim}
export JDK_HOME=/opt/products/java/1.4.2
\end{verbatim}

to point to the Java Development Kit of your system.
Make the settings available to your shell by sourcing the script:

\begin{verbatim}
. ./env.sh 
\end{verbatim}

To build Gear as well as the API documentation
issue the following commands:

\begin{verbatim}
ant aid.generate 
ant cpp 
ant cpp.doc 
\end{verbatim}

\subsubsection*{MarlinReco}

The top level makefile of the Marlin package is designed in a way that it
builds Marlin together with MarlinReco, MarlinUtil and the CEDViewer. 
This works only if MarlinReco, MarlinUtil and CEDViewer are moved to the 
{\tt packages} subdirectory of Marlin. To decouple Marlin form the
other packages their subdirectories are linked using symbolic links to  
Marlin's {\tt packages} directory:

\begin{verbatim} 
cd $LCSoft/Marlin/packages
ln -s $LCSoft//packages/CEDViewer
ln -s $LCSoft//packages/MarlinReco
ln -s $LCSoft//packages/MarlinUtil
\end{verbatim}

A few variables have to be set depending on your development
environment. For user convenience there already exists a script
{\tt MarlinRecoEnv.sh} in the MarlinReco subdirectory, where you can change 
the paths as needed. The meaning of the variables together with the 
default values for the DESY computing environment are given here.

\begin{itemize}
\item {\tt export LCIO=/opt/products/lcio/1.5} \\
      Path to the LCIO package directory.
\item {\tt export MARLINDEBUG=1} \\
      Include debug information in output (1 = on). 
      Comment out this line for production code. 
\item {\tt export CLHEP=/opt/products/CLHEP/1.8.2} \\ 
      Path to the CLHEP package. Be sure to use version 1.8.2. 
      There will be problems with later versions due to the useage of 
      namespaces.
\item {\tt export GSL\_HOME=/afs/desy.de/group/it/ilcsoft/gsl/1.6} \\
      Path to the ``GNU Scientific Library'' (GSL).
\item {\tt export CERNLIB\_HOME=/opt/products/cernlib/pro/lib} \\
      Path to the ``CERN programming library'' (CERNLIB).
\item {\tt export MARLIN\_USE\_AIDA=1} \\
      This option enables Marlin to produce histograms using the 
      the AIDA~\cite{ref_aida} interface. 
\item {\tt export JDK\_HOME=/opt/products/java/1.4.2} \\
      Path to the Java Development Kit. 
\item {\tt export JAIDA\_HOME=/opt/products/JAIDA/3.2.3} \\
      Java implementation of the AIDA interface.
\item {\tt export AIDAJNI\_HOME=/opt/products/AIDAJNI/3.2.3} \\
      Java Native Interface to access JAIDA from \CPP{}. 
\end{itemize}

Edit the script as needed and copy it to the Marlin directory to
replace the {\tt env.sh} script shipped with Marlin:

\begin{verbatim}
cd $LCSoft/Marlin 
cp \$LCSoft/Marlin/packages/MarlinReco/MarlinRecoEnv.sh env.sh
\end{verbatim}

Source it to setup the environment:

\begin{verbatim}
. env.sh 
\end{verbatim}

In addition the ``env.sh'' script of MarlinReco produces the file 
{\tt userlibMarlinReco.gmk} containing some additional paths 
to include and library directories which are necessary to build 
MarlinReco. Edit this file, if you need to add 
more include and library paths for own processors. To make the settings 
available to the Marlin top level makefile replace the dummy file 
{\tt userlib.gmk}:

\begin{verbatim}
mv userlibMarlinReco.gmk userlib.gmk
\end{verbatim}

To build MarlinReco type in the Marlin directory:

\begin{verbatim}
gmake
\end{verbatim}

This will create the MarlinReco executable {\tt \$LCSoft/Marlin/binMarlin}. 
Simultaneous to MarlinReco also the MarlinUtil library and the CEDviewer is 
build. 

\section{Further Information}
Documentation
Links to our portal, workshops, homepages
test DVD

% -----------------------------------------------------------------------------
\begin{thebibliography}{99}
\bibitem{ref_gear}
see: \htmladdnormallink{http://ilcsoft.desy.de/gear}{http://ilcsoft.desy.de/gear}
\bibitem{ref_marlin}
see: \htmladdnormallink{http://ilcsoft.desy.de/marlin}{http://ilcsoft.desy.de/marlin}
\bibitem{ref_lciohome}
see: \htmladdnormallink{http://lcio.desy.de}{http://lcio.desy.de}
\bibitem{ref_lcio}{F.~Gaede, T.~Behnke, N.~Graf, T.~Johnson
{\em CHEP03 March24-28, 2003 La Jolla, USA},
TUKT001, \em arXiv:physics/0306114}.
\bibitem{ref_tdr}
  T.~Behnke {\it et al.}, (ed.), ``Tesla TDR, Pt.~4'',
%T.~.~(.~Behnke, S.~.~(.~Bertolucci, R.~D.~.~Heuer and R.~.~(.~Settles,
%``TESLA: The superconducting electron positron linear collider with an
%integrated X-ray laser laboratory. Technical design report.  Pt. 4: A
%detector for TESLA,''
DESY-01-011
%\href{http://www.slac.stanford.edu/spires/find/hep/www?r=desy-01-011}{SPIRES
% entry}
\bibitem{ref_geant4}
S.~Agostinelli {\it et al.}  [GEANT4 Collaboration],
%``GEANT4: A simulation toolkit,''
Nucl.\ Instrum.\ Meth.\ A {\bf 506} (2003) 250.
\bibitem{ref_jupiter}
T.~Aso, K.~Hoshina, K.~Fujii and A.~Miyamoto,
%``JUPITER GEANT4 based detector simulator for JLC,''
%\href{http://www.slac.stanford.edu/spires/find/hep/www?irn=6067883}{SPIRES
% entry}
%{\it Prepared for International Workshop on Linear Colliders (LCWS 2002),
% Jeju Island, Korea, 26-30 Aug 2002}
{\it Prepared for LCWS 2002, Jeju Island, Korea, 26-30 Aug 2002}
\bibitem{ref_slic}
J.~McCormick,
%``Full Detector Simulation Using Slic And Lcdd,''
SLAC-PUB-11418
%\href{http://www.slac.stanford.edu/spires/find/hep/www?r=slac-pub-11418}
% {SPIRES entry}
%{\it Contributed to 2005 International Linear Collider Workshop (LCWS 2005),
% Stanford, California, 18-22 Mar 2005}
{\it Contributed to LCWS 2005, Stanford, California, 18-22 Mar 2005}
\bibitem{ref_mokka}
%Mokka Homepage: \\
%\verb#http://polywww.in2p3.fr/geant4/tesla/www/mokka/# \\
%\verb# ... mokka.html#
  P.~Mora de Freitas and H.~Videau, LC-TOOL-2003-010
%\href{http://www.slac.stanford.edu/spires/find/hep/www?r=lc-tool-2003-010}
% {SPIRES entry}
{\it Prepared for LCWS 2002, Jeju Island, Korea, 26-30 Aug 2002}
\bibitem{ref_brahms}
  T.~Behnke {\it et al.}, LC-TOOL-2001-005,
see: \htmladdnormallink{http://www-flc.desy.de/lcnotes}{http://www-flc.desy.de/lcnotes}
%\href{http://www.slac.stanford.edu/spires/find/hep/www?irn=4787218}{SPIRES
% entry}
%{\it Prepared for 5th International Linear Collider Workshop (LCWS 2000),
% Fermilab, Batavia, Illinois, 24-28 Oct 2000}
\bibitem{ref_aid}
AID Homepage:\\  
\htmladdnormallink{http://java.freehep.org/aid/index.html}{http://java.freehep.org/aid/index.html}
%
\bibitem{ref_gsl}
GSL homepage: \\
\htmladdnormallink{http://www.gnu.org/software/gsl/}{http://www.gnu.org/software/gsl/}.
\bibitem{ref_cernlib}
CERNLIB homepage: \\
\htmladdnormallink{http://cern.ch/cernlib/}{http://cern.ch/cernlib/}
\bibitem{ref_clhep}
CLHEP homepage: \\
\htmladdnormallink{http://wwwasd.web.cern.ch/wwwasd/lhc++/clhep/}{http://wwwasd.web.cern.ch/wwwasd/lhc++/clhep/}
\bibitem{ref_aida}
AIDA homepage: \\
\htmladdnormallink{http://aida.freehep.org}{http://aida.freehep.org}
\bibitem{ref_jaida}
JAIDA homepage:\\
\htmladdnormallink{http://java.freehep.org/jaida}{http://java.freehep.org/jaida}
\bibitem{ref_aidajni}
AIDA-JNI homepage:\\
\htmladdnormallink{http://java.freehep.org/aidajni}{http://java.freehep.org/aidajni}
\end{thebibliography}

% hyperlink: \htmladdnormallink{}{}
